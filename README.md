a) Назовем вектором строку битов (значения 0 или 1) фиксированной длины N: то есть, всего возможно 2N различных векторов.

b) Введем операцию сложения по модулю 2 векторов (операция xor), которая по двум векторам a и b получает вектор a + b той же длины N.

c) Пусть дано множество A = {ai | i ∈ 1..K} из 0 ≤ K ≤ 2N векторов. Назовем его порождающим: при помощи сложения ai множества A можно получить 2K векторов вида ∑i=1..Kbiai, где bi равно либо 0, либо 1.

d) Весом вектора назовем количество единичных (ненулевых) битов в векторе: то есть, вес — это натуральное число от 0 до N.

Требуется для заданных порождающих множества векторов и числа N построить гистограмму (спектр) количества различных векторов по их весу.

Формат входных данных:
Текстовый файл из набора строк одинаковой длины по одному вектору в строке (символы 0 и 1 без разделителей).

Формат выходных данных:
Текстовый файл с парой значений вес/количество разделенных символом табуляции, по одной паре на строку, сортированный по числовому значению веса.


Представлены 4 файла из разных проектов.

Все требуют входного файла in.txt (для питона должен включать в себя только строки с векторами, для с++ в первой строке должены быть числа N и K), выходного - out.txt

spectre.py - код на питоне, в предположении, что "различные векторы" = уникальные среди результирующих

spectre.cpp - код на С++, в предположении, что "различные векторы" = уникальные среди результирующих

parallelCPU.cpp - код на С++, в переположении, что "различные векторы" = все результирующие векторы. В программе реализовано двухуровневое распараллеливание с помощью MPI и OpenMP.

parallelGPU.cu - код на С++, в переположении, что "различные векторы" = все результирующие векторы. В программе реализовано распараллеливание на графическом ускорителе NVIDIA с помощью технологии CUDA.

parallel_time.xlsx - Таблица эксель с результатами замеров времени для распараллеленых программ.
